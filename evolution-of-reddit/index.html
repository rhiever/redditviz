<!DOCTYPE html>
<meta charset="utf-8">
<title>Evolution of reddit</title>
<style type="text/css">

.link {
  stroke: #ccc;
}

.overlay {
  fill: none;
  pointer-events: all;
}

#reddit-date {
	;
}

</style>
<link rel="stylesheet" href="http://code.jquery.com/ui/1.9.0/themes/base/jquery-ui.css" />
<script src="http://code.jquery.com/jquery-1.8.2.js"></script>
<script src="http://code.jquery.com/ui/1.9.0/jquery-ui.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>

<body>

<div id="reddit-date"></div>
<div id="slider">
  <script>
    $(function() {
    $("#slider").slider({
    min: 0,
    max: 83,
    value: 0,
    slide: function( event, ui ) {
    	month = 1 + ui.value % 12;
    	year = 2006 + Math.floor(ui.value / 12);
    	showReddit();
    }});
    });
  </script>
</div>

<script>

var w = window,
    d = document,
    e = d.documentElement,
    g = d.getElementsByTagName('body')[0],
    x = w.innerWidth || e.clientWidth || g.clientWidth,
    y = w.innerHeight|| e.clientHeight|| g.clientHeight;

var width = x - 20,
    height = y - 100;
    padding = 20, // separation between same-color circles
    clusterPadding = 20, // separation between different-color circles
    maxRadius = 0;

var force = d3.layout.force()
    .charge(function(d) { return -d.size; })
    .linkDistance(function(d) { return (1.0 / d.weight); })
    .linkStrength(function(d) { return d.weight; })
    .gravity(1)
    .size([width/2, height/2]);

var color = d3.scale.category20();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("background-color", "#3A3A3A")
    .append("g")
    .call(d3.behavior.zoom().scaleExtent([0.3, 2]).on("zoom", zoom))
	.append("g");
    
    function zoom() {
		svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
	}
	
	svg.append("rect")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height);

var year = 2006;
var month = 1;

showReddit();

function showReddit() {

	document.getElementById("reddit-date").innerHTML = String(month) + "/" + String(year);

	force.stop();
	
	svg.selectAll(".node")
	  .data([])
	  .exit().remove();
	svg.selectAll("text")
	  .data([])
	  .exit().remove();
	svg.selectAll(".link")
	  .data([])
	  .exit().remove();

	d3.json("data/reddit-network-" + String(year) + "-" + String(month) + ".json", function(error, graph) {
	
		var numClusters = 0;
		var numNodes = 0;
		var clusters = [];
		var biggestNode;
	
		var nodes = svg.selectAll(".node")
		  .data(graph.nodes)
		  .enter().append("circle")
		  .attr("class", "node")
		  .attr("r", function(d) { return Math.log(d.size); })
		  .style("fill", function(d) { return color(d.cluster); })
		  .style("stroke", function(d) { return color(d.cluster); })
		  .on("mouseover", function(d) { d3.select(".nodelabel" + d.name).style("visibility", "visible"); })
		  .on("mouseout",
			function(d) {
				if (d.size < 0.5 * biggestNode.size && d.name != clusters[d.cluster].name) {
					d3.select(".nodelabel" + d.name).style("visibility", "hidden");
				}
			});
			
		graph.nodes.forEach(function(d, i) {
			numNodes += 1;
			
			if (d.r > maxRadius) { maxRadius = d.r; }
			
			if (!(d.cluster in clusters)) {
				numClusters += 1;
				clusters.push(d.cluster);
			}
		});
		
		// The largest node for each cluster
		var clusters = new Array(numClusters);
		graph.nodes.forEach(function(d, i) {
			if (!clusters[d.cluster] || (d.size > clusters[d.cluster].size)) clusters[d.cluster] = d;
			if (!biggestNode || (d.size > biggestNode.size)) biggestNode = d;
		});
	
	  var links = svg.selectAll(".link")
		  .data(graph.links)
		.enter().append("path") //("line")
		  .attr("class", "link")
		  .attr("strength", function(d) { return d.weight; })
		  .style("stroke-width", function(d) { return d.weight; })
		  .style("fill", "none")
		  .style("stroke-color", "white");
	
	  var texts = svg.selectAll("text.label")
					.data(graph.nodes)
					.enter().append("text")
					.attr("class", function(d) { return "nodelabel" + d.name; })
					.attr("fill", "white")
					.style("cursor", "default")
					.style("-webkit-user-select", "none")
					.style("-webkit-touch-callout", "none")
					.style("-moz-user-select", "none")
					.style("-ms-user-select", "none")
					.style("-khtml-user-select", "none")
					.style("user-select", "none")
					.style("visibility", function(d) {
						if (d.size >= 0.5 * biggestNode.size || d.name == clusters[d.cluster].name) { return "visible"; }
						else { return "hidden"; }
					})
					.text(function(d) { return d.name; });
	
		// Move d to be adjacent to the cluster node.
		function cluster(alpha) {
		  return function(d) {
			var cluster = clusters[d.cluster];
			if (cluster.name == d.name) return;
			var x = d.x - cluster.x,
				y = d.y - cluster.y,
				l = Math.sqrt(x * x + y * y),
				r = Math.log(d.size) + Math.log(cluster.size);
			if (l != r) {
			  l = (l - r) / l * alpha;
			  d.x -= x *= l;
			  d.y -= y *= l;
			  cluster.x += x;
			  cluster.y += y;
			}
		  };
		}
		
		// Resolves collisions between d and all other circles.
		function collide(alpha, realAlpha) {
			if (realAlpha < 0.01) return;
			
			var quadtree = d3.geom.quadtree(nodes);
			return function(d) {
				var r = d.r + maxRadius + Math.max(padding, clusterPadding),
					nx1 = d.x - r,
					nx2 = d.x + r,
					ny1 = d.y - r,
					ny2 = d.y + r;
				quadtree.visit(function(quad, x1, y1, x2, y2) {
				  if (quad.point && (quad.point !== d)) {
					var x = d.x - quad.point.x,
						y = d.y - quad.point.y,
						l = Math.sqrt(x * x + y * y),
						r = d.r + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
					if (l < r) {
					  l = (l - r) / l * alpha;
					  d.x -= x *= l;
					  d.y -= y *= l;
					  quad.point.x += x;
					  quad.point.y += y;
					}
				  }
				return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
				});
			};
	  }
		
		force.nodes(graph.nodes)
		   .links(graph.links)
		   .start()
		   .on("tick", tick);
		//for (var i = 150; i > 0; --i) force.tick(d3.event);
		//force.stop();
	  
	  function tick(e) {
		//biggestNode.x = width / 2;
		//biggestNode.y = height / 2;
		
		nodes.each(cluster(10 * e.alpha * e.alpha))
			//.each(collide(.5, e.alpha))
			.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; });
			  
		links.attr("d", function(d) {
			var dx = d.target.x - d.source.x,
				dy = d.target.y - d.source.y,
				dr = Math.sqrt(dx * dx + dy * dy);
			return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
			});
			
		texts.attr("transform", function(d) { return "translate(" + d.x + "," + d.y+100 + ")"; })
	  }
	});
	
	month += 1;
	if (month > 12) {
		month = 1;
		year += 1;
	}
}

</script>